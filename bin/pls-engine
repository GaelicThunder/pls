#!/usr/bin/env bash
# pls-engine: Streams to stderr, outputs single clean command to stdout

set -euo pipefail

CONFIG_DIR="$HOME/.config/pls"
CONFIG_FILE="$CONFIG_DIR/config.json"
USER_PROMPT="${1:-}"
CURRENT_SHELL="${2:-bash}"

RED="\033[0;31m"
GREEN="\033[0;32m"
YELLOW="\033[0;33m"
BLUE="\033[0;34m"
NC="\033[0m"

debug() { [ "${DEBUG:-}" = "1" ] && echo -e "${YELLOW}[DEBUG]${NC} $*" >&2; }
error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }
info() { echo -e "${BLUE}[INFO]${NC} $*" >&2; }

FRAMES=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")

# Default config values
create_default_config() {
  mkdir -p "$CONFIG_DIR"
  cat > "$CONFIG_FILE" << EOL
{
  "model": "gemma3:4b",
  "ollama_url": "http://localhost:11434",
  "temperature": 0.1,
  "system_prompt": "You are a shell command generator. Output exactly one single-line command for the requested task. No explanations, no markdown, no code fences, no language tags. Only the raw command.",
  "shell_specific_prompts": {
    "fish": "Generate Fish shell commands using Fish-specific syntax (e.g., 'set' for variables, Fish conditionals).",
    "bash": "Generate Bash shell commands using POSIX syntax.",
    "zsh": "Generate Zsh shell commands using Zsh-specific features if beneficial."
  }
}
EOL
}

show_thinking() {
  local pid=$1
  local i=0
  while kill -0 "$pid" 2>/dev/null; do
    printf "\r${BLUE}${FRAMES[i]} Generating...${NC}" >&2
    ((i = (i + 1) % ${#FRAMES[@]}))
    sleep 0.1
  done
  printf "\r\033[K" >&2
}

stream_response() {
  local model="$1" url="$2" prompt="$3" temp="$4"

  local json_payload
  json_payload=$(jq -n \
    --arg model "$model" \
    --arg prompt "$prompt" \
    --argjson stream true \
    --argjson temp "$temp" \
    '{model: $model, prompt: $prompt, stream: $stream, options: {temperature: $temp}}')

  local response_file
  response_file=$(mktemp)
  # Run curl in the background to capture its PID
  curl -s "$url/api/generate" -d "$json_payload" > "$response_file" &
  local curl_pid=$!

  show_thinking "$curl_pid"
  wait "$curl_pid"

  local command=""
  # Process the JSON stream from Ollama
  while IFS= read -r line; do
    # Extract the response part from the JSON line
    local part
    part=$(echo "$line" | jq -r '.response // empty')
    if [ -n "$part" ]; then
      printf "%s" "$part" >&2  # Stream raw response to stderr for the user to see
      command+="$part"
    fi
    # Check if the stream is done
    local done
    done=$(echo "$line" | jq -r '.done // false')
    [ "$done" = "true" ] && break
  done < "$response_file"

  printf "\n" >&2  # Newline after stream finishes
  if [ -z "$command" ]; then
    error "No valid command generated. Raw response from Ollama:"
    cat "$response_file" >&2
  fi
  rm -f "$response_file"
  
  # Clean and output the final command to stdout
  # This sed command performs multiple clean-up steps safely without destroying quotes:
  # 1. Removes all backticks (`).
  # 2. Removes common language prefixes (bash, fish, etc.) from the start.
  # 3. Trims leading and trailing whitespace.
  # This replaces the problematic `xargs` which strips quotes.
  command=$(echo "$command" | sed -e 's/`//g' -e 's/^shell//' -e 's/^bash//' -e 's/^fish//' -e 's/^zsh//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
  
  echo "$command"
}


# Main
[ -z "$USER_PROMPT" ] && { error "Usage: pls-engine \"<prompt>\" [shell]"; exit 1; }
command -v jq >/dev/null || { error "jq required"; exit 1; }
command -v curl >/dev/null || { error "curl required"; exit 1; }

[ ! -f "$CONFIG_FILE" ] && create_default_config

MODEL=$(jq -r '.model' "$CONFIG_FILE")
OLLAMA_URL=$(jq -r '.ollama_url' "$CONFIG_FILE")
TEMPERATURE=$(jq -r '.temperature' "$CONFIG_FILE")
SYSTEM_PROMPT=$(jq -r '.system_prompt' "$CONFIG_FILE")
SHELL_SPECIFIC=$(jq -r ".shell_specific_prompts.\"$CURRENT_SHELL\" // empty" "$CONFIG_FILE")

FINAL_PROMPT="$SYSTEM_PROMPT $SHELL_SPECIFIC User request: $USER_PROMPT"

info "Generating command for $CURRENT_SHELL..."
SUGGESTED_CMD=$(stream_response "$MODEL" "$OLLAMA_URL" "$FINAL_PROMPT" "$TEMPERATURE")

echo "$SUGGESTED_CMD"
